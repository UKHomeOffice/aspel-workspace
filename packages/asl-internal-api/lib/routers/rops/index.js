const { Router } = require('express');
const { NotFoundError } = require('@asl/service/errors');
const permissions = require('@asl/service/lib/middleware/permissions');
const whitelist = require('../../middleware/whitelist');

const submit = () => (req, res, next) => {
  const params = {
    model: 'export',
    meta: {
      changedBy: req.user.profile.id
    },
    data: {
      type: 'rops',
      key: req.year,
      profileId: req.user.profile.id
    }
  };

  return req.workflow.create(params)
    .then(response => {
      res.response = response.json.data;
      next();
    })
    .catch(next);
};

module.exports = () => {
  const router = Router();

  router.use(permissions('asruRops'));

  router.param('year', (req, res, next, year) => {
    if (!year.match(/^20[0-9]{2}/)) {
      throw new NotFoundError();
    }
    req.year = year;
    next();
  });

  router.get('/:year/summary', (req, res, next) => {
    const { Project } = req.models;
    const year = req.year;

    let due = 0;
    let submitted = 0;
    let outstanding = 0;
    let overdue = 0;

    return Project.query()
      .select('id')
      .selectRopsDeadline(year)
      .whereRopsDue(year)
      .withRops(year, 'submitted')
      .then(projects => {
        due = projects.length;
        submitted = projects.filter(p => p.ropsSubmittedDate).length;
        outstanding = due - submitted;
        const now = (new Date()).toISOString();

        projects.forEach(p => {
          if (!p.ropsSubmittedDate && p.ropsDeadline < now) {
            overdue++;
          }
        });

        res.response = { year, due, submitted, outstanding, overdue };
      })
      .then(() => next())
      .catch(next);
  });

  router.get('/:year/establishments', (req, res, next) => {
    const { Establishment, Project } = req.models;
    const { limit, offset, search, sort = {} } = req.query;
    const year = req.year;
    const now = (new Date()).toISOString();

    const ropsQuery = Establishment.relatedQuery('projects').count('id').whereRopsDue(year);

    // get a list of all projects for the establishment with outstanding rops
    // ropsDeadline is generated by a SELECT so it cannot be used in a WHERE or a HAVING at this level
    const outstandingRops = Project.query()
      .select('id')
      .selectRopsDeadline(year)
      // overdueQuery is plain Knex not Objection, so Establishment.relatedQuery() doesn't work -
      // replace it with standard FK link
      .whereRaw('projects.establishment_id = establishments.id')
      .whereRopsDue(year)
      .whereRopsOutstanding(year);

    // from the list of projects with outstanding rops, count the ones with a deadline in the past
    // overdueQuery wraps the outstandingRops query so that we can use ropsDeadline in a WHERE
    const overdueQuery = Establishment.knex()
      .with('outstandingRops', outstandingRops.toKnexQuery())
      .count()
      .from('outstandingRops')
      .where('outstandingRops.ropsDeadline', '<', now);

    let query = Establishment.query()
      .select('id', 'name')
      .select(ropsQuery.clone().as('ropsDue'))
      .select(ropsQuery.clone().whereRopsSubmitted(year).as('ropsSubmitted'))
      .select(ropsQuery.clone().whereRopsOutstanding(year).as('ropsOutstanding'))
      .select(overdueQuery.as('ropsOverdue'));

    if (search) {
      query.where('establishments.name', 'ilike', `%${search}%`);
    }

    query = Establishment.orderBy({ query, sort });
    query = Establishment.paginate({ query, limit, offset });

    const total = Establishment.query()
      .where({ status: 'active' })
      .count()
      .then(result => result[0].count);

    return Promise.all([ total, query ])
      .then(([total, establishments]) => {
        res.meta.total = total;
        res.meta.count = establishments.total;
        res.response = establishments.results;
        return next();
      })
      .catch(next);
  });

  router.use('/:year/export', (req, res, next) => {
    const { Export } = req.models;
    return Export.query()
      .withGraphFetched('profile')
      .where({ key: req.year })
      .orderBy('createdAt', 'desc')
      .then(result => {
        req.exports = result;
      })
      .then(() => next())
      .catch(next);
  });

  router.get('/:year/export/:exportId', (req, res, next) => {
    const { Export } = req.models;
    return Export.query()
      .findById(req.params.exportId)
      .then(result => {
        res.response = result;
      })
      .then(() => next())
      .catch(next);
  });

  router.get('/:year/export', (req, res, next) => {
    res.response = req.exports;
    next();
  });

  router.post('/:year/export',
    (req, res, next) => {
      // if there is already a pending request then don't create another
      if (req.exports.find(row => !row.ready)) {
        res.response = {};
        return next('router');
      }
      next();
    },
    whitelist(),
    submit()
  );

  return router;
};
