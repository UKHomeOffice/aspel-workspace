#!/usr/bin/env node

try {
  require('dotenv').config();
} catch (e) {}

const { get } = require('lodash');
const minimist = require('minimist');
const winston = require('winston');
const settings = require('../config');
const db = require('../lib/db');
const taskflowDb = require('../lib/db/taskflow');
const { createESClient } = require('../lib/elasticsearch');
const { indexers } = require('../lib/indexers');
const logger = require('../lib/logger');

const args = minimist(process.argv.slice(2));
const model = args._[0] || 'all';

class IndexManager {
  constructor(esClient, options = {}) {
    this.esClient = esClient;
    this.options = options;
    this.stats = {
      startTime: Date.now(),
      processed: 0,
      errors: 0
    };

    // Define large indexes that need special handling
    this.largeIndexes = ['projects', 'projects-content', 'tasks'];
  }

  async indexAll() {
    logger.info('Starting sequential indexing for all models...');

    const indexKeys = Object.keys(indexers);
    const results = [];

    // Process indexes sequentially using for loop
    for (const [index, key] of indexKeys.entries()) {
      logger.info(`Processing: ${key} (${index + 1}/${indexKeys.length})`);

      const result = await this.indexSingle(key);
      results.push(result);

      // Add cooling period between indexes, especially after large ones
      if (index < indexKeys.length - 1) {
        const delayTime = this.largeIndexes.includes(key) ? 10000 : 2000;
        logger.info(`Cooling down for ${delayTime/1000} seconds...`);
        await this.delay(delayTime);
      }
    }

    return this.report(results);
  }

  async indexSingle(key) {
    const startTime = Date.now();
    logger.info(`Indexing ${key}...`);

    try {
      const indexer = indexers[key];
      if (!indexer) {
        throw new Error(`No indexer available for ${key}`);
      }

      let result;
      if (key === 'tasks') {
        result = await indexer({
          aslSchema: db,
          taskflowDb,
          esClient: this.esClient,
          logger,
          options: this.options
        });
      } else {
        result = await indexer(db, this.esClient, this.options);
      }

      const duration = Date.now() - startTime;
      const rate = result && typeof result === 'number' ? Math.round(result / (duration / 1000)) : 'N/A';

      if (typeof result === 'number') {
        logger.info(`✓ Completed ${key}: ${result} records in ${duration}ms (${rate} records/sec)`);
      } else {
        logger.info(`✓ Completed ${key} in ${duration}ms`);
      }

      return { key, success: true, duration, result };
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(`✗ Failed ${key} after ${duration}ms: ${error.message}`);

      return { key, success: false, duration, error: error.message };
    }
  }

  async report(results) {
    const totalTime = Date.now() - this.stats.startTime;
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;

    logger.info('\n' + '='.repeat(50));
    logger.info('INDEXING COMPLETE');
    logger.info('='.repeat(50));
    logger.info(`Successful: ${successful}`);
    logger.info(`Failed: ${failed}`);
    logger.info(`Total time: ${Math.round(totalTime / 1000)}s`);

    // Log detailed results
    results.forEach(result => {
      if (result.success) {
        const recordInfo = typeof result.result === 'number' ? ` (${result.result} records)` : '';
        logger.info(`  ✓ ${result.key}: ${result.duration}ms${recordInfo}`);
      } else {
        logger.error(`  ✗ ${result.key}: ${result.error}`);
      }
    });

    return { successful, failed, totalTime };
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Graceful shutdown handling
process.on('SIGINT', async () => {
  logger.warn('\nReceived SIGINT. Shutting down gracefully...');
  await cleanup();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.warn('\nReceived SIGTERM. Shutting down gracefully...');
  await cleanup();
  process.exit(0);
});

async function cleanup() {
  try {
    logger.info('Closing database connections...');
    await Promise.allSettled([
      db.destroy(),
      taskflowDb.destroy()
    ]);
    logger.info('Cleanup completed');
  } catch (error) {
    logger.error('Cleanup error:', error);
  }
}

// Main execution
async function main() {
  const start = process.hrtime();

  try {
    const esClient = await createESClient(settings.es);
    const manager = new IndexManager(esClient, args);

    let result;
    if (model === 'all') {
      result = await manager.indexAll();
    } else {
      result = await manager.indexSingle(model);
    }

    const end = process.hrtime(start);
    const totalMs = (end[0] * 1000) + Math.round(end[1] / 1e6);
    logger.info(`\nTotal script execution: ${totalMs}ms (${Math.round(totalMs / 1000)}s)`);

    await cleanup();
    process.exit(result.failed > 0 ? 1 : 0);

  } catch (error) {
    logger.error('Fatal error:', error);
    await cleanup();
    process.exit(1);
  }
}

main();
