#!/usr/bin/env node
const assert = require('assert');
const { execSync } = require('child_process');
const { IAM } = require('aws-sdk');

const args = require('minimist')(process.argv.slice(2));

const commands = {
  dev: 'kubectl --context=acp-notprod_ASL --namespace=asl-dev',
  preprod: 'kubectl --context=acp-notprod_ASL --namespace=asl-preprod',
  prod: 'kubectl --context=acp-prod_ASL --namespace=asl-prod'
};

const KUBE_NAMESPACE = args.namespace;
const SECRET_NAME = args._[0];
const KUBE_COMMAND = commands[KUBE_NAMESPACE];

assert(KUBE_COMMAND, `Unrecognised namespace: "${KUBE_NAMESPACE}"`);
assert(SECRET_NAME, `Secret name must be provided`);

const getSecret = () => {
  const secret = execSync(`${KUBE_COMMAND} get secret ${SECRET_NAME} --output=json`);
  return JSON.parse(secret);
}

const getKeysFromSecret = async () => {
  const secretConfig = getSecret();
  const accessKeyId = Buffer.from(secretConfig.data.access_key_id, 'base64').toString('utf8');
  const secretAccessKey = Buffer.from(secretConfig.data.secret_access_key, 'base64').toString('utf8');
  return { accessKeyId, secretAccessKey };
};

const cleanKeys = async (credentials) => {
  const existing = await listKeys(credentials);

  if (existing.length === 2) {
    const spareKey = existing.find(key => key.AccessKeyId !== credentials.accessKeyId);
    await deleteKey(credentials, spareKey.AccessKeyId);
  }
};

const listKeys = (credentials) => {
  const client = new IAM({
    region: 'eu-west-2',
    ...credentials
  });

  return new Promise((resolve, reject) => {
    client.listAccessKeys((err, result) => {
      if (err) {
        return reject(err);
      }
      const { AccessKeyMetadata } = result;
      resolve(AccessKeyMetadata);
    });
  });
};

const deleteKey = (credentials, AccessKeyId) => {
  const client = new IAM({
    region: 'eu-west-2',
    ...credentials
  });
  return new Promise((resolve, reject) => {
    client.deleteAccessKey({ AccessKeyId } ,err => {
      err ? reject(err) : resolve();
    });
  });
};

const createKey = async (credentials) => {
  await cleanKeys(credentials);

  const client = new IAM({
    region: 'eu-west-2',
    ...credentials
  });

  return new Promise((resolve, reject) => {
    client.createAccessKey((err, result) => {
      if (err) {
        return reject(err);
      }
      const { AccessKey } = result;
      resolve({
        accessKeyId: AccessKey.AccessKeyId,
        secretAccessKey: AccessKey.SecretAccessKey
      });
    });
  });
}

const refreshSecret = async (keys) => {
  const secretConfig = getSecret();
  secretConfig.data.access_key_id = Buffer.from(keys.accessKeyId).toString('base64');
  secretConfig.data.secret_access_key = Buffer.from(keys.secretAccessKey).toString('base64');

  execSync(`${KUBE_COMMAND} apply -f -`, { input: JSON.stringify(secretConfig) });
};

const restart = async (name) => {
  process.stdout.write(`* ${name}`);
  execSync(`${KUBE_COMMAND} rollout restart deployment/${name}`);
  execSync(`${KUBE_COMMAND} rollout status deployment/${name}`);
  process.stdout.write(' ✅\n');
};

const restartPods = async () => {
  const deployments = JSON.parse(execSync(`${KUBE_COMMAND} get deployments --output=json`));
  for (const deployment of deployments.items) {
    const usesSecret = deployment.spec.template.spec.containers.some(container => {
      return container.env.some(env => env.valueFrom && env.valueFrom.secretKeyRef.name === SECRET_NAME);
    });
    if (usesSecret) {
      await restart(deployment.metadata.name);
    }
  }
};

const main = async () => {
  process.stdout.write('Fetching existing AWS keys... ');
  const oldKeys = await getKeysFromSecret();
  process.stdout.write('✅\n');
  process.stdout.write('Creating new AWS keys... ');
  const newKeys = await createKey(oldKeys);
  process.stdout.write('✅\n');

  process.stdout.write('Updating secret... ');
  await refreshSecret(newKeys);
  process.stdout.write('✅\n');
  process.stdout.write('Restarting pods:\n');
  await restartPods();
  process.stdout.write('Removing old keys... ');
  await cleanKeys(newKeys);
  process.stdout.write('✅\n');
  const keys = await listKeys(newKeys);
  console.log(keys);
};

main()
  .then(() => process.exit())
  .catch(e => {
    console.error(e.stack);
    process.exit(1);
  });
