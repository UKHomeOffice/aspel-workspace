#!/usr/bin/env node
try {
  require('dotenv/config');
} catch (e) {
  // ignore
}

const { Octokit } = require('@octokit/rest');
const moment = require('moment');
const { get } = require('lodash');

if (!process.env.GITHUB_ACCESS_TOKEN) {
  throw new Error('GITHUB_ACCESS_TOKEN is required');
}

const owner = 'ukhomeoffice';
const repo = 'asl-deployments';
const auth = process.env.GITHUB_ACCESS_TOKEN;

const octokit = new Octokit({ auth });

const getStaleBranches = async () => {
  const branches = await octokit.rest.repos.listBranches({ owner, repo });
  const stale = [];
  for (const branch of branches.data) {
    const ref = `heads/${branch.name}`;
    const commit = await octokit.rest.repos.getCommit({
      owner,
      repo,
      ref
    });
    const date = get(commit.data, 'commit.author.date');
    if (moment(date).isBefore(moment().subtract(5, 'days'))) {
      stale.push(branch.name);
    }
  }
  return stale;
};

const filterBranches = branches => {
  return branches.filter(branch => branch.match(/failures-|visual-regression-/));
};

const deleteStaleBranches = async branches => {
  for (const branch of branches) {
    const ref = `heads/${branch}`;
    await octokit.rest.git.deleteRef({
      owner,
      repo,
      ref
    });
  }
};

Promise.resolve()
  .then(() => getStaleBranches())
  .then(branches => filterBranches(branches))
  .then(branches => deleteStaleBranches(branches))
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e.stack);
    process.exit(1);
  });
